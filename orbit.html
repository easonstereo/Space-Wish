<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>星宇心愿 · 高清贴图 + 小纸条 + 星空</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #popup {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 15px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      box-shadow: 0 0 8px #fff;
      line-height: 1.6;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="popup">Loading…</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.umd.min.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 13);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding; // ✅ 添加正确色域渲染
document.body.appendChild(renderer.domElement);

// 光源与太阳
const ambient = new THREE.AmbientLight(0x404040, 0);
scene.add(ambient);
const sunLight = new THREE.DirectionalLight(0xffffff, 0.5);
sunLight.position.set(100, 0, 30);
scene.add(sunLight);
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(1.5, 32, 32),
  new THREE.MeshBasicMaterial({ color: 0xffffaa })
);
sun.position.copy(sunLight.position);
scene.add(sun);

// === 高清地球 + 云层（官方示例贴图）===
const loader = new THREE.TextureLoader();
const earthGroup = new THREE.Group();
scene.add(earthGroup);

// 地球
const earth = new THREE.Mesh(
  new THREE.SphereGeometry(2, 64, 64),
  new THREE.MeshPhongMaterial({
    map: loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),     // 白天贴图
    bumpMap: loader.load('https://threejs.org/examples/textures/planets/earth_bump_2048.jpg'),   // 地形起伏
    bumpScale: 0.08,
    
    // ✅ 去除镜面反射
    shininess: 0,
    specular: new THREE.Color(0x000000),

    // ✅ 夜景灯光（用于暗面城市发光）
    emissiveMap: loader.load('https://threejs.org/examples/textures/planets/earth_lights_2048.png'),
    emissive: new THREE.Color(0x222222),          // 发光颜色（暗灰）
    emissiveIntensity: 1                        // 可调：越大越亮
  })
);

earthGroup.add(earth);

// 云层
const cloud = new THREE.Mesh(
  new THREE.SphereGeometry(2.03, 64, 64),
  new THREE.MeshPhongMaterial({
    map: loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'),
    transparent: true,
    opacity: 0.38,
    depthWrite: false
  })
);
earthGroup.add(cloud);

// 月球
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(0.5, 64, 64),
  new THREE.MeshPhongMaterial({
    map: loader.load('https://raw.githubusercontent.com/fireship-io/threejs-scroll-animation-demo/main/moon.jpg'),
    bumpMap: loader.load('https://threejs.org/examples/textures/planets/moon_bump_1024.jpg'),
    bumpScale: 0.03
  })
);
scene.add(moon);

// 小纸条
const satellite = new THREE.Mesh(
  new THREE.BoxGeometry(0.3, 0.2, 0.02),
  new THREE.MeshStandardMaterial({
    color: 0xffffff,
    metalness: 0.1,
    roughness: 0.6,
    emissive: new THREE.Color(0xffffff),
    emissiveIntensity: 0.3
  })
);
scene.add(satellite);

// 星空粒子背景
const starsGeo = new THREE.BufferGeometry();
const starCount = 600;
const starPositions = new Float32Array(starCount * 3);
for (let i = 0; i < starCount; i++) {
  const r = 140, theta = Math.random() * 2 * Math.PI, phi = Math.acos(2 * Math.random() - 1);
  starPositions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
  starPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
  starPositions[i*3+2] = r * Math.cos(phi);
}
starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.4 });
const starMesh = new THREE.Points(starsGeo, starMaterial);
scene.add(starMesh);

// 卫星轨道线
const trailPoints = [];
const inclination = THREE.MathUtils.degToRad(45);
const offset = THREE.MathUtils.degToRad(100);
for (let i = 0; i <= 360; i += 3) {
  const rad = THREE.MathUtils.degToRad(i);
  const orbitX = 5 * Math.cos(rad);
  const orbitZ = 5 * Math.sin(rad) * Math.cos(inclination);
  const orbitY = 5 * Math.sin(rad) * Math.sin(inclination);
  const x = orbitX * Math.cos(offset) - orbitZ * Math.sin(offset);
  const z = orbitX * Math.sin(offset) + orbitZ * Math.cos(offset);
  trailPoints.push(new THREE.Vector3(x, orbitY, z));
}
const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
const trail = new THREE.Points(trailGeometry, new THREE.PointsMaterial({ size: 0.06, transparent: true, opacity: 0.25 }));
scene.add(trail);

// 时间系统
const startDate = new Date("2025-12-31T00:00:00Z");
const endDate = new Date("2026-12-31T00:00:00Z");
const duration = endDate.getTime() - startDate.getTime();
let angle = 0, colorPhase = 0, t = 0;

// 动画主循环
function animate() {
  requestAnimationFrame(animate);
  angle += 0.005;
  colorPhase += 0.01;
  t += 16;

  earth.rotation.y += 0.001;
  cloud.rotation.y += 0.0012;
  starMaterial.opacity = 0.3 + 0.2 * Math.sin(colorPhase * 0.5);

  const radius = 5 + 0.2 * Math.sin(angle * 2);
  const baseX = radius * Math.cos(angle);
  const baseZ = radius * Math.sin(angle) * Math.cos(inclination);
  const baseY = radius * Math.sin(angle) * Math.sin(inclination);
  const x = baseX * Math.cos(offset) - baseZ * Math.sin(offset);
  const z = baseX * Math.sin(offset) + baseZ * Math.cos(offset);
  const y = baseY;
  satellite.position.set(x, y, z);
  satellite.rotation.x = Math.sin(angle * 2) * 0.5;
  satellite.rotation.y = angle;
  satellite.rotation.z = Math.cos(angle * 2.5) * 0.5;

  const moonAngle = angle * 0.1;
  moon.position.set(
    10 * Math.cos(moonAngle),
    2.0 * Math.sin(moonAngle),
    10 * Math.sin(moonAngle)
  );

  const simTime = new Date(startDate.getTime() + (t % duration));
  const timeStr = simTime.toISOString().split("T")[0];
  const lat = Math.asin(y / radius) * 180 / Math.PI;
  const lon = Math.atan2(z, x) * 180 / Math.PI;
  const distance = (radius - 2) * 100;
  document.getElementById("popup").innerHTML =
    `<strong>编号：</strong>XYX-20250818<br>
     <strong>昵称：</strong>星愿使者<br>
     <strong>祝福：</strong>愿你心之所向，星辰皆可抵达<br>
     <strong>时间：</strong>${timeStr}<br>
     <strong>轨道高度：</strong>${distance.toFixed(2)} km<br>
     <strong>纬度：</strong>${lat.toFixed(4)}°<br>
     <strong>经度：</strong>${lon.toFixed(4)}°`;

  renderer.render(scene, camera);
}
animate();

// 自适应
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 控制面板
const gui = new lil.GUI({ title: 'Lighting Controls' });
const ambFolder = gui.addFolder('Ambient Light');
const ambParams = { color: '#404040', intensity: ambient.intensity };
ambFolder.addColor(ambParams, 'color').name('Color').onChange(v => ambient.color.set(v));
ambFolder.add(ambParams, 'intensity', 0, 5, 0.01).name('Intensity').onChange(v => ambient.intensity = v);
ambFolder.open();

const sunFolder = gui.addFolder('Sun Light');
const sunParams = {
  color: '#ffffff',
  intensity: sunLight.intensity,
  x: sunLight.position.x, y: sunLight.position.y, z: sunLight.position.z
};
sunFolder.addColor(sunParams, 'color').name('Color').onChange(v => sunLight.color.set(v));
sunFolder.add(sunParams, 'intensity', 0, 5, 0.01).name('Intensity').onChange(v => sunLight.intensity = v);
sunFolder.add(sunParams, 'x', -100, 100, 0.1).name('Pos X').onChange(v => { sunLight.position.x = v; sun.position.x = v; });
sunFolder.add(sunParams, 'y', -100, 100, 0.1).name('Pos Y').onChange(v => { sunLight.position.y = v; sun.position.y = v; });
sunFolder.add(sunParams, 'z', -100, 100, 0.1).name('Pos Z').onChange(v => { sunLight.position.z = v; sun.position.z = v; });
sunFolder.open();
</script>
</body>
</html>
